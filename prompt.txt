nesses códigos:

color.ts
"""
// hue-variationion-value (HSV) 0 - 360

enum Colors {
    HTML = 5,
    URL = 220,
    AI = 120,
    MISCELLANEOUS = 300,
}

export default Colors;
"""

types.ts
"""
enum BlocklyTypes {
    htmlElement = 'htmlElement',
    htmlElementVariable = 'elementoHTML1',
    textVariable = 'variavelTextual1',
    textVariable2 = 'variavelTextual2',
    urlVariable = 'variavelURL1',
    promptVariable = 'variavelPrompt1',
}

export default BlocklyTypes;
"""

blocklyFields.ts
"""
type TypeBlocklyFieldText = {
    type: 'text';
    text: string;
}

type TypeBlocklyFieldVariable = {
    type: 'field_variable';
    name: string;
    variable: string;
    variableTypes: string[];
    dataType?: string;
};

type TypeBlocklyFieldInput = {
    type: 'field_input';
    name: string;
    text: string;
};

type TypeBlocklyFieldDropdown = {
    type: 'field_dropdown';
    name: string;
    options: [string, string][]; // [value, text]
};

type TypeBlocklyFieldCheckbox = {
    type: 'field_checkbox';
    name: string;
    checked: boolean;
};

export type TypeBlocklyInputValue = {
    type: 'input_value';
    name: string;
    check?: string | string[];
    shadow?: {
        type: 'text' | 'number';
        fields: {
            [key: string]: string | number;
        };
    },
};

type TypeBlocklyStatementInput = {
    type: 'input_statement';
    name: string;
};

type TypeBlocklyFields = TypeBlocklyFieldText | TypeBlocklyFieldVariable | TypeBlocklyFieldInput | TypeBlocklyFieldDropdown | TypeBlocklyFieldCheckbox | TypeBlocklyInputValue | TypeBlocklyStatementInput;

export default TypeBlocklyFields;
"""

blockConstructor.ts
"""
import * as Blockly from 'blockly';
import { javascriptGenerator, Order } from 'blockly/javascript';
import TypeColorBlock from '../../types/blockColor';
import TypeBlocklyFields, { TypeBlocklyInputValue } from '../../types/blocklyFields';
import TypeInputBlock from '../../types/blocklyInputs';

const blockConstructorErrorHandling = (
  blockConfig: blockConstructorInterface
) => {
  if (
    blockConfig.hasOutput !== undefined &&
    blockConfig.hasNextConnection !== undefined
  ) {
    throw new Error(
      'A block cannot have output and next connection at the same time'
    );
  }

  if (
    blockConfig.hasOutput !== undefined &&
    blockConfig.hasPreviousConnection !== undefined
  ) {
    throw new Error(
      'A block cannot have output and previous connection at the same time'
    );
  }

  if (
    blockConfig.fields.filter((field) => field.type === 'text').length
  ) {
    throw new Error('A block cannot have a text field');
  }
};

type TypeConnection = string | string[] | null;

export type TypeBlockly = {
  kind: string;
  type: string;
};

interface blockConstructorInterface {
  colour: TypeColorBlock;
  fields: TypeBlocklyFields[];
  generator?: (block: any, generator: any) => string;
  hasNextConnection?: TypeConnection;
  hasOutput?: TypeConnection;
  hasPreviousConnection?: TypeConnection;
  helpUrl: string;
  inputs?: TypeInputBlock;
  message: string;
  name: string;
  tooltip: string;
}

const blockConstructor = (blockConfig: blockConstructorInterface): TypeBlockly => {
  blockConstructorErrorHandling(blockConfig);

  const {
    colour,
    fields,
    hasNextConnection,
    hasOutput,
    hasPreviousConnection,
    helpUrl,
    inputs,
    message,
    name,
    tooltip,
  } = blockConfig;

  const jsonInitExtra: {
    [key: string]: any;
  } = {};

  if (hasNextConnection !== undefined) {
    jsonInitExtra['nextStatement'] = hasNextConnection;
  }

  if (hasPreviousConnection !== undefined) {
    jsonInitExtra['previousStatement'] = hasPreviousConnection;
  }

  if (hasOutput !== undefined) {
    jsonInitExtra['output'] = hasOutput;
  }

  const message0 = message;
  let args0: any = [];

  fields.forEach((field, index) => {
    args0.push(field);
  });

  Blockly.Blocks[name] = {
    init: function () {
      this.jsonInit({
        args0,
        colour,
        helpUrl,
        message0,
        tooltip,
        ...jsonInitExtra,
      });

      fields.filter((field) => field.type === 'input_value' && !!field.shadow).forEach((field) => {
        const formattedField = field as any;

        const selectorInput = this.getInput(formattedField.name);
        if (selectorInput && !selectorInput.connection.getShadowDom()) {
          const shadowXml = document.createElement('shadow');
          shadowXml.setAttribute('type', formattedField.shadow.type);

          const fields = formattedField.shadow.fields;

          Object.keys(fields).forEach((key) => {
            const fieldXml = document.createElement('field');
            fieldXml.setAttribute('name', key);
            fieldXml.textContent = fields[key];

            shadowXml.appendChild(fieldXml);
          });

          selectorInput.connection.setShadowDom(shadowXml);
        }
      });
    },
  };

  if (blockConfig.generator) {
    javascriptGenerator.forBlock[name] = blockConfig.generator;
  } else {
    javascriptGenerator.forBlock[name] = function (block, generator) {
      return '/* Generator not implemented */';
    };
  }

  return {
    kind: 'block',
    type: name,
    ...inputs ? { inputs } : {},
  };
};

export default blockConstructor;
"""

e nesse exemplo de implementação

BlockPromptUser.ts
"""
import * as Blockly from 'blockly/core';
import Colors from '../../../config/colors';
import blockConstructor from '../../../helpers/blockConstructor';
import BlocklyTypes from '../../../config/types';

const setBlockPromptUser = () => {
    return blockConstructor({
        colour: Colors.HTML,
        hasOutput: BlocklyTypes.textVariable,
        helpUrl: 'https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt',
        message: 'browser prompt %1',
        name: 'BlockPromptUser',
        tooltip: 'Exibe um prompt para o usuário inserir informações.',
        fields: [
            {
                type: 'input_value',
                name: 'PROMPT_MESSAGE',
                shadow: {
                    type: 'text',
                    fields: {
                        TEXT: 'Digite a sua pergunta'
                    }
                }
            },
        ],
        generator: function (block: Blockly.Block, generator: any) {
            return '/* not implemented yet */';
        },
    });
};

export default setBlockPromptUser;

"""

Crie um BlockConfirmUser
Função: Exibe um window confirm para o usuaário aceitar ou cancelar

!!! important: se precisar alterar um dos arquivos ou funções existentes, adicione na resposta o que deve mudar e onde !!!
!!! important: não crie lógica para o generator, apenas copie o /* not implemented yet */ !!!